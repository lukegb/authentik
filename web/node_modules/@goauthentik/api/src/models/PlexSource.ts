/* tslint:disable */
/* eslint-disable */
/**
 * authentik
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2024.2.1
 * Contact: hello@goauthentik.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import type { PolicyEngineMode } from './PolicyEngineMode';
import {
    PolicyEngineModeFromJSON,
    PolicyEngineModeFromJSONTyped,
    PolicyEngineModeToJSON,
} from './PolicyEngineMode';
import type { UserMatchingModeEnum } from './UserMatchingModeEnum';
import {
    UserMatchingModeEnumFromJSON,
    UserMatchingModeEnumFromJSONTyped,
    UserMatchingModeEnumToJSON,
} from './UserMatchingModeEnum';

/**
 * Plex Source Serializer
 * @export
 * @interface PlexSource
 */
export interface PlexSource {
    /**
     * 
     * @type {string}
     * @memberof PlexSource
     */
    readonly pk: string;
    /**
     * Source's display Name.
     * @type {string}
     * @memberof PlexSource
     */
    name: string;
    /**
     * Internal source name, used in URLs.
     * @type {string}
     * @memberof PlexSource
     */
    slug: string;
    /**
     * 
     * @type {boolean}
     * @memberof PlexSource
     */
    enabled?: boolean;
    /**
     * Flow to use when authenticating existing users.
     * @type {string}
     * @memberof PlexSource
     */
    authenticationFlow?: string | null;
    /**
     * Flow to use when enrolling new users.
     * @type {string}
     * @memberof PlexSource
     */
    enrollmentFlow?: string | null;
    /**
     * Get object component so that we know how to edit the object
     * @type {string}
     * @memberof PlexSource
     */
    readonly component: string;
    /**
     * Return object's verbose_name
     * @type {string}
     * @memberof PlexSource
     */
    readonly verboseName: string;
    /**
     * Return object's plural verbose_name
     * @type {string}
     * @memberof PlexSource
     */
    readonly verboseNamePlural: string;
    /**
     * Return internal model name
     * @type {string}
     * @memberof PlexSource
     */
    readonly metaModelName: string;
    /**
     * 
     * @type {PolicyEngineMode}
     * @memberof PlexSource
     */
    policyEngineMode?: PolicyEngineMode;
    /**
     * 
     * @type {UserMatchingModeEnum}
     * @memberof PlexSource
     */
    userMatchingMode?: UserMatchingModeEnum;
    /**
     * Objects that are managed by authentik. These objects are created and updated automatically. This flag only indicates that an object can be overwritten by migrations. You can still modify the objects via the API, but expect changes to be overwritten in a later update.
     * @type {string}
     * @memberof PlexSource
     */
    readonly managed: string | null;
    /**
     * 
     * @type {string}
     * @memberof PlexSource
     */
    userPathTemplate?: string;
    /**
     * Get the URL to the Icon. If the name is /static or
     * starts with http it is returned as-is
     * @type {string}
     * @memberof PlexSource
     */
    readonly icon: string | null;
    /**
     * Client identifier used to talk to Plex.
     * @type {string}
     * @memberof PlexSource
     */
    clientId?: string;
    /**
     * Which servers a user has to be a member of to be granted access. Empty list allows every server.
     * @type {Array<string>}
     * @memberof PlexSource
     */
    allowedServers?: Array<string>;
    /**
     * Allow friends to authenticate, even if you don't share a server.
     * @type {boolean}
     * @memberof PlexSource
     */
    allowFriends?: boolean;
    /**
     * Plex token used to check friends
     * @type {string}
     * @memberof PlexSource
     */
    plexToken: string;
}

/**
 * Check if a given object implements the PlexSource interface.
 */
export function instanceOfPlexSource(value: object): boolean {
    let isInstance = true;
    isInstance = isInstance && "pk" in value;
    isInstance = isInstance && "name" in value;
    isInstance = isInstance && "slug" in value;
    isInstance = isInstance && "component" in value;
    isInstance = isInstance && "verboseName" in value;
    isInstance = isInstance && "verboseNamePlural" in value;
    isInstance = isInstance && "metaModelName" in value;
    isInstance = isInstance && "managed" in value;
    isInstance = isInstance && "icon" in value;
    isInstance = isInstance && "plexToken" in value;

    return isInstance;
}

export function PlexSourceFromJSON(json: any): PlexSource {
    return PlexSourceFromJSONTyped(json, false);
}

export function PlexSourceFromJSONTyped(json: any, ignoreDiscriminator: boolean): PlexSource {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'pk': json['pk'],
        'name': json['name'],
        'slug': json['slug'],
        'enabled': !exists(json, 'enabled') ? undefined : json['enabled'],
        'authenticationFlow': !exists(json, 'authentication_flow') ? undefined : json['authentication_flow'],
        'enrollmentFlow': !exists(json, 'enrollment_flow') ? undefined : json['enrollment_flow'],
        'component': json['component'],
        'verboseName': json['verbose_name'],
        'verboseNamePlural': json['verbose_name_plural'],
        'metaModelName': json['meta_model_name'],
        'policyEngineMode': !exists(json, 'policy_engine_mode') ? undefined : PolicyEngineModeFromJSON(json['policy_engine_mode']),
        'userMatchingMode': !exists(json, 'user_matching_mode') ? undefined : UserMatchingModeEnumFromJSON(json['user_matching_mode']),
        'managed': json['managed'],
        'userPathTemplate': !exists(json, 'user_path_template') ? undefined : json['user_path_template'],
        'icon': json['icon'],
        'clientId': !exists(json, 'client_id') ? undefined : json['client_id'],
        'allowedServers': !exists(json, 'allowed_servers') ? undefined : json['allowed_servers'],
        'allowFriends': !exists(json, 'allow_friends') ? undefined : json['allow_friends'],
        'plexToken': json['plex_token'],
    };
}

export function PlexSourceToJSON(value?: PlexSource | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'name': value.name,
        'slug': value.slug,
        'enabled': value.enabled,
        'authentication_flow': value.authenticationFlow,
        'enrollment_flow': value.enrollmentFlow,
        'policy_engine_mode': PolicyEngineModeToJSON(value.policyEngineMode),
        'user_matching_mode': UserMatchingModeEnumToJSON(value.userMatchingMode),
        'user_path_template': value.userPathTemplate,
        'client_id': value.clientId,
        'allowed_servers': value.allowedServers,
        'allow_friends': value.allowFriends,
        'plex_token': value.plexToken,
    };
}

