/* tslint:disable */
/* eslint-disable */
/**
 * authentik
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2024.2.1
 * Contact: hello@goauthentik.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  CertificateData,
  CertificateGenerationRequest,
  CertificateKeyPair,
  CertificateKeyPairRequest,
  GenericError,
  PaginatedCertificateKeyPairList,
  PatchedCertificateKeyPairRequest,
  UsedBy,
  ValidationError,
} from '../models';
import {
    CertificateDataFromJSON,
    CertificateDataToJSON,
    CertificateGenerationRequestFromJSON,
    CertificateGenerationRequestToJSON,
    CertificateKeyPairFromJSON,
    CertificateKeyPairToJSON,
    CertificateKeyPairRequestFromJSON,
    CertificateKeyPairRequestToJSON,
    GenericErrorFromJSON,
    GenericErrorToJSON,
    PaginatedCertificateKeyPairListFromJSON,
    PaginatedCertificateKeyPairListToJSON,
    PatchedCertificateKeyPairRequestFromJSON,
    PatchedCertificateKeyPairRequestToJSON,
    UsedByFromJSON,
    UsedByToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface CryptoCertificatekeypairsCreateRequest {
    certificateKeyPairRequest: CertificateKeyPairRequest;
}

export interface CryptoCertificatekeypairsDestroyRequest {
    kpUuid: string;
}

export interface CryptoCertificatekeypairsGenerateCreateRequest {
    certificateGenerationRequest: CertificateGenerationRequest;
}

export interface CryptoCertificatekeypairsListRequest {
    hasKey?: boolean;
    includeDetails?: boolean;
    managed?: string;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
}

export interface CryptoCertificatekeypairsPartialUpdateRequest {
    kpUuid: string;
    patchedCertificateKeyPairRequest?: PatchedCertificateKeyPairRequest;
}

export interface CryptoCertificatekeypairsRetrieveRequest {
    kpUuid: string;
}

export interface CryptoCertificatekeypairsUpdateRequest {
    kpUuid: string;
    certificateKeyPairRequest: CertificateKeyPairRequest;
}

export interface CryptoCertificatekeypairsUsedByListRequest {
    kpUuid: string;
}

export interface CryptoCertificatekeypairsViewCertificateRetrieveRequest {
    kpUuid: string;
    download?: boolean;
}

export interface CryptoCertificatekeypairsViewPrivateKeyRetrieveRequest {
    kpUuid: string;
    download?: boolean;
}

/**
 * 
 */
export class CryptoApi extends runtime.BaseAPI {

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsCreateRaw(requestParameters: CryptoCertificatekeypairsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateKeyPair>> {
        if (requestParameters.certificateKeyPairRequest === null || requestParameters.certificateKeyPairRequest === undefined) {
            throw new runtime.RequiredError('certificateKeyPairRequest','Required parameter requestParameters.certificateKeyPairRequest was null or undefined when calling cryptoCertificatekeypairsCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CertificateKeyPairRequestToJSON(requestParameters.certificateKeyPairRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateKeyPairFromJSON(jsonValue));
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsCreate(requestParameters: CryptoCertificatekeypairsCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateKeyPair> {
        const response = await this.cryptoCertificatekeypairsCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsDestroyRaw(requestParameters: CryptoCertificatekeypairsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsDestroy(requestParameters: CryptoCertificatekeypairsDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.cryptoCertificatekeypairsDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Generate a new, self-signed certificate-key pair
     */
    async cryptoCertificatekeypairsGenerateCreateRaw(requestParameters: CryptoCertificatekeypairsGenerateCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateKeyPair>> {
        if (requestParameters.certificateGenerationRequest === null || requestParameters.certificateGenerationRequest === undefined) {
            throw new runtime.RequiredError('certificateGenerationRequest','Required parameter requestParameters.certificateGenerationRequest was null or undefined when calling cryptoCertificatekeypairsGenerateCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/generate/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: CertificateGenerationRequestToJSON(requestParameters.certificateGenerationRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateKeyPairFromJSON(jsonValue));
    }

    /**
     * Generate a new, self-signed certificate-key pair
     */
    async cryptoCertificatekeypairsGenerateCreate(requestParameters: CryptoCertificatekeypairsGenerateCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateKeyPair> {
        const response = await this.cryptoCertificatekeypairsGenerateCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsListRaw(requestParameters: CryptoCertificatekeypairsListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedCertificateKeyPairList>> {
        const queryParameters: any = {};

        if (requestParameters.hasKey !== undefined) {
            queryParameters['has_key'] = requestParameters.hasKey;
        }

        if (requestParameters.includeDetails !== undefined) {
            queryParameters['include_details'] = requestParameters.includeDetails;
        }

        if (requestParameters.managed !== undefined) {
            queryParameters['managed'] = requestParameters.managed;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedCertificateKeyPairListFromJSON(jsonValue));
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsList(requestParameters: CryptoCertificatekeypairsListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedCertificateKeyPairList> {
        const response = await this.cryptoCertificatekeypairsListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsPartialUpdateRaw(requestParameters: CryptoCertificatekeypairsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateKeyPair>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedCertificateKeyPairRequestToJSON(requestParameters.patchedCertificateKeyPairRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateKeyPairFromJSON(jsonValue));
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsPartialUpdate(requestParameters: CryptoCertificatekeypairsPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateKeyPair> {
        const response = await this.cryptoCertificatekeypairsPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsRetrieveRaw(requestParameters: CryptoCertificatekeypairsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateKeyPair>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateKeyPairFromJSON(jsonValue));
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsRetrieve(requestParameters: CryptoCertificatekeypairsRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateKeyPair> {
        const response = await this.cryptoCertificatekeypairsRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsUpdateRaw(requestParameters: CryptoCertificatekeypairsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateKeyPair>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsUpdate.');
        }

        if (requestParameters.certificateKeyPairRequest === null || requestParameters.certificateKeyPairRequest === undefined) {
            throw new runtime.RequiredError('certificateKeyPairRequest','Required parameter requestParameters.certificateKeyPairRequest was null or undefined when calling cryptoCertificatekeypairsUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: CertificateKeyPairRequestToJSON(requestParameters.certificateKeyPairRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateKeyPairFromJSON(jsonValue));
    }

    /**
     * CertificateKeyPair Viewset
     */
    async cryptoCertificatekeypairsUpdate(requestParameters: CryptoCertificatekeypairsUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateKeyPair> {
        const response = await this.cryptoCertificatekeypairsUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async cryptoCertificatekeypairsUsedByListRaw(requestParameters: CryptoCertificatekeypairsUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/used_by/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async cryptoCertificatekeypairsUsedByList(requestParameters: CryptoCertificatekeypairsUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.cryptoCertificatekeypairsUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return certificate-key pairs certificate and log access
     */
    async cryptoCertificatekeypairsViewCertificateRetrieveRaw(requestParameters: CryptoCertificatekeypairsViewCertificateRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateData>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsViewCertificateRetrieve.');
        }

        const queryParameters: any = {};

        if (requestParameters.download !== undefined) {
            queryParameters['download'] = requestParameters.download;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/view_certificate/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateDataFromJSON(jsonValue));
    }

    /**
     * Return certificate-key pairs certificate and log access
     */
    async cryptoCertificatekeypairsViewCertificateRetrieve(requestParameters: CryptoCertificatekeypairsViewCertificateRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateData> {
        const response = await this.cryptoCertificatekeypairsViewCertificateRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return certificate-key pairs private key and log access
     */
    async cryptoCertificatekeypairsViewPrivateKeyRetrieveRaw(requestParameters: CryptoCertificatekeypairsViewPrivateKeyRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<CertificateData>> {
        if (requestParameters.kpUuid === null || requestParameters.kpUuid === undefined) {
            throw new runtime.RequiredError('kpUuid','Required parameter requestParameters.kpUuid was null or undefined when calling cryptoCertificatekeypairsViewPrivateKeyRetrieve.');
        }

        const queryParameters: any = {};

        if (requestParameters.download !== undefined) {
            queryParameters['download'] = requestParameters.download;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/crypto/certificatekeypairs/{kp_uuid}/view_private_key/`.replace(`{${"kp_uuid"}}`, encodeURIComponent(String(requestParameters.kpUuid))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => CertificateDataFromJSON(jsonValue));
    }

    /**
     * Return certificate-key pairs private key and log access
     */
    async cryptoCertificatekeypairsViewPrivateKeyRetrieve(requestParameters: CryptoCertificatekeypairsViewPrivateKeyRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<CertificateData> {
        const response = await this.cryptoCertificatekeypairsViewPrivateKeyRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
