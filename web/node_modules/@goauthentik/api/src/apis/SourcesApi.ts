/* tslint:disable */
/* eslint-disable */
/**
 * authentik
 * Making authentication simple.
 *
 * The version of the OpenAPI document: 2024.2.1
 * Contact: hello@goauthentik.io
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  FilePathRequest,
  GenericError,
  LDAPDebug,
  LDAPSource,
  LDAPSourceRequest,
  LDAPSyncStatus,
  OAuthSource,
  OAuthSourceRequest,
  PaginatedLDAPSourceList,
  PaginatedOAuthSourceList,
  PaginatedPlexSourceConnectionList,
  PaginatedPlexSourceList,
  PaginatedSAMLSourceList,
  PaginatedSourceList,
  PaginatedUserOAuthSourceConnectionList,
  PaginatedUserSAMLSourceConnectionList,
  PaginatedUserSourceConnectionList,
  PatchedLDAPSourceRequest,
  PatchedOAuthSourceRequest,
  PatchedPlexSourceConnectionRequest,
  PatchedPlexSourceRequest,
  PatchedSAMLSourceRequest,
  PatchedUserOAuthSourceConnectionRequest,
  PatchedUserSAMLSourceConnectionRequest,
  PlexSource,
  PlexSourceConnection,
  PlexSourceConnectionRequest,
  PlexSourceRequest,
  PlexTokenRedeemRequest,
  RedirectChallenge,
  SAMLMetadata,
  SAMLSource,
  SAMLSourceRequest,
  Source,
  SourceType,
  TypeCreate,
  UsedBy,
  UserOAuthSourceConnection,
  UserOAuthSourceConnectionRequest,
  UserSAMLSourceConnection,
  UserSAMLSourceConnectionRequest,
  UserSetting,
  UserSourceConnection,
  ValidationError,
} from '../models';
import {
    FilePathRequestFromJSON,
    FilePathRequestToJSON,
    GenericErrorFromJSON,
    GenericErrorToJSON,
    LDAPDebugFromJSON,
    LDAPDebugToJSON,
    LDAPSourceFromJSON,
    LDAPSourceToJSON,
    LDAPSourceRequestFromJSON,
    LDAPSourceRequestToJSON,
    LDAPSyncStatusFromJSON,
    LDAPSyncStatusToJSON,
    OAuthSourceFromJSON,
    OAuthSourceToJSON,
    OAuthSourceRequestFromJSON,
    OAuthSourceRequestToJSON,
    PaginatedLDAPSourceListFromJSON,
    PaginatedLDAPSourceListToJSON,
    PaginatedOAuthSourceListFromJSON,
    PaginatedOAuthSourceListToJSON,
    PaginatedPlexSourceConnectionListFromJSON,
    PaginatedPlexSourceConnectionListToJSON,
    PaginatedPlexSourceListFromJSON,
    PaginatedPlexSourceListToJSON,
    PaginatedSAMLSourceListFromJSON,
    PaginatedSAMLSourceListToJSON,
    PaginatedSourceListFromJSON,
    PaginatedSourceListToJSON,
    PaginatedUserOAuthSourceConnectionListFromJSON,
    PaginatedUserOAuthSourceConnectionListToJSON,
    PaginatedUserSAMLSourceConnectionListFromJSON,
    PaginatedUserSAMLSourceConnectionListToJSON,
    PaginatedUserSourceConnectionListFromJSON,
    PaginatedUserSourceConnectionListToJSON,
    PatchedLDAPSourceRequestFromJSON,
    PatchedLDAPSourceRequestToJSON,
    PatchedOAuthSourceRequestFromJSON,
    PatchedOAuthSourceRequestToJSON,
    PatchedPlexSourceConnectionRequestFromJSON,
    PatchedPlexSourceConnectionRequestToJSON,
    PatchedPlexSourceRequestFromJSON,
    PatchedPlexSourceRequestToJSON,
    PatchedSAMLSourceRequestFromJSON,
    PatchedSAMLSourceRequestToJSON,
    PatchedUserOAuthSourceConnectionRequestFromJSON,
    PatchedUserOAuthSourceConnectionRequestToJSON,
    PatchedUserSAMLSourceConnectionRequestFromJSON,
    PatchedUserSAMLSourceConnectionRequestToJSON,
    PlexSourceFromJSON,
    PlexSourceToJSON,
    PlexSourceConnectionFromJSON,
    PlexSourceConnectionToJSON,
    PlexSourceConnectionRequestFromJSON,
    PlexSourceConnectionRequestToJSON,
    PlexSourceRequestFromJSON,
    PlexSourceRequestToJSON,
    PlexTokenRedeemRequestFromJSON,
    PlexTokenRedeemRequestToJSON,
    RedirectChallengeFromJSON,
    RedirectChallengeToJSON,
    SAMLMetadataFromJSON,
    SAMLMetadataToJSON,
    SAMLSourceFromJSON,
    SAMLSourceToJSON,
    SAMLSourceRequestFromJSON,
    SAMLSourceRequestToJSON,
    SourceFromJSON,
    SourceToJSON,
    SourceTypeFromJSON,
    SourceTypeToJSON,
    TypeCreateFromJSON,
    TypeCreateToJSON,
    UsedByFromJSON,
    UsedByToJSON,
    UserOAuthSourceConnectionFromJSON,
    UserOAuthSourceConnectionToJSON,
    UserOAuthSourceConnectionRequestFromJSON,
    UserOAuthSourceConnectionRequestToJSON,
    UserSAMLSourceConnectionFromJSON,
    UserSAMLSourceConnectionToJSON,
    UserSAMLSourceConnectionRequestFromJSON,
    UserSAMLSourceConnectionRequestToJSON,
    UserSettingFromJSON,
    UserSettingToJSON,
    UserSourceConnectionFromJSON,
    UserSourceConnectionToJSON,
    ValidationErrorFromJSON,
    ValidationErrorToJSON,
} from '../models';

export interface SourcesAllDestroyRequest {
    slug: string;
}

export interface SourcesAllListRequest {
    managed?: string;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    slug?: string;
}

export interface SourcesAllRetrieveRequest {
    slug: string;
}

export interface SourcesAllSetIconCreateRequest {
    slug: string;
    file?: Blob;
    clear?: boolean;
}

export interface SourcesAllSetIconUrlCreateRequest {
    slug: string;
    filePathRequest: FilePathRequest;
}

export interface SourcesAllUsedByListRequest {
    slug: string;
}

export interface SourcesLdapCreateRequest {
    lDAPSourceRequest: LDAPSourceRequest;
}

export interface SourcesLdapDebugRetrieveRequest {
    slug: string;
}

export interface SourcesLdapDestroyRequest {
    slug: string;
}

export interface SourcesLdapListRequest {
    additionalGroupDn?: string;
    additionalUserDn?: string;
    baseDn?: string;
    bindCn?: string;
    clientCertificate?: string;
    enabled?: boolean;
    groupMembershipField?: string;
    groupObjectFilter?: string;
    name?: string;
    objectUniquenessField?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    peerCertificate?: string;
    propertyMappings?: Array<string>;
    propertyMappingsGroup?: Array<string>;
    search?: string;
    serverUri?: string;
    slug?: string;
    sni?: boolean;
    startTls?: boolean;
    syncGroups?: boolean;
    syncParentGroup?: string;
    syncUsers?: boolean;
    syncUsersPassword?: boolean;
    userObjectFilter?: string;
}

export interface SourcesLdapPartialUpdateRequest {
    slug: string;
    patchedLDAPSourceRequest?: PatchedLDAPSourceRequest;
}

export interface SourcesLdapRetrieveRequest {
    slug: string;
}

export interface SourcesLdapSyncStatusRetrieveRequest {
    slug: string;
}

export interface SourcesLdapUpdateRequest {
    slug: string;
    lDAPSourceRequest: LDAPSourceRequest;
}

export interface SourcesLdapUsedByListRequest {
    slug: string;
}

export interface SourcesOauthCreateRequest {
    oAuthSourceRequest: OAuthSourceRequest;
}

export interface SourcesOauthDestroyRequest {
    slug: string;
}

export interface SourcesOauthListRequest {
    accessTokenUrl?: string;
    additionalScopes?: string;
    authenticationFlow?: string;
    authorizationUrl?: string;
    consumerKey?: string;
    enabled?: boolean;
    enrollmentFlow?: string;
    hasJwks?: boolean;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    policyEngineMode?: SourcesOauthListPolicyEngineModeEnum;
    profileUrl?: string;
    providerType?: string;
    requestTokenUrl?: string;
    search?: string;
    slug?: string;
    userMatchingMode?: SourcesOauthListUserMatchingModeEnum;
}

export interface SourcesOauthPartialUpdateRequest {
    slug: string;
    patchedOAuthSourceRequest?: PatchedOAuthSourceRequest;
}

export interface SourcesOauthRetrieveRequest {
    slug: string;
}

export interface SourcesOauthSourceTypesListRequest {
    name?: string;
}

export interface SourcesOauthUpdateRequest {
    slug: string;
    oAuthSourceRequest: OAuthSourceRequest;
}

export interface SourcesOauthUsedByListRequest {
    slug: string;
}

export interface SourcesPlexCreateRequest {
    plexSourceRequest: PlexSourceRequest;
}

export interface SourcesPlexDestroyRequest {
    slug: string;
}

export interface SourcesPlexListRequest {
    allowFriends?: boolean;
    authenticationFlow?: string;
    clientId?: string;
    enabled?: boolean;
    enrollmentFlow?: string;
    name?: string;
    ordering?: string;
    page?: number;
    pageSize?: number;
    policyEngineMode?: SourcesPlexListPolicyEngineModeEnum;
    search?: string;
    slug?: string;
    userMatchingMode?: SourcesPlexListUserMatchingModeEnum;
}

export interface SourcesPlexPartialUpdateRequest {
    slug: string;
    patchedPlexSourceRequest?: PatchedPlexSourceRequest;
}

export interface SourcesPlexRedeemTokenAuthenticatedCreateRequest {
    plexTokenRedeemRequest: PlexTokenRedeemRequest;
    slug?: string;
}

export interface SourcesPlexRedeemTokenCreateRequest {
    plexTokenRedeemRequest: PlexTokenRedeemRequest;
    slug?: string;
}

export interface SourcesPlexRetrieveRequest {
    slug: string;
}

export interface SourcesPlexUpdateRequest {
    slug: string;
    plexSourceRequest: PlexSourceRequest;
}

export interface SourcesPlexUsedByListRequest {
    slug: string;
}

export interface SourcesSamlCreateRequest {
    sAMLSourceRequest: SAMLSourceRequest;
}

export interface SourcesSamlDestroyRequest {
    slug: string;
}

export interface SourcesSamlListRequest {
    allowIdpInitiated?: boolean;
    authenticationFlow?: string;
    bindingType?: SourcesSamlListBindingTypeEnum;
    digestAlgorithm?: SourcesSamlListDigestAlgorithmEnum;
    enabled?: boolean;
    enrollmentFlow?: string;
    issuer?: string;
    managed?: string;
    name?: string;
    nameIdPolicy?: SourcesSamlListNameIdPolicyEnum;
    ordering?: string;
    page?: number;
    pageSize?: number;
    policyEngineMode?: SourcesSamlListPolicyEngineModeEnum;
    preAuthenticationFlow?: string;
    search?: string;
    signatureAlgorithm?: SourcesSamlListSignatureAlgorithmEnum;
    signingKp?: string;
    sloUrl?: string;
    slug?: string;
    ssoUrl?: string;
    temporaryUserDeleteAfter?: string;
    userMatchingMode?: SourcesSamlListUserMatchingModeEnum;
    verificationKp?: string;
}

export interface SourcesSamlMetadataRetrieveRequest {
    slug: string;
}

export interface SourcesSamlPartialUpdateRequest {
    slug: string;
    patchedSAMLSourceRequest?: PatchedSAMLSourceRequest;
}

export interface SourcesSamlRetrieveRequest {
    slug: string;
}

export interface SourcesSamlUpdateRequest {
    slug: string;
    sAMLSourceRequest: SAMLSourceRequest;
}

export interface SourcesSamlUsedByListRequest {
    slug: string;
}

export interface SourcesUserConnectionsAllDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsAllListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    user?: number;
}

export interface SourcesUserConnectionsAllPartialUpdateRequest {
    id: number;
}

export interface SourcesUserConnectionsAllRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsAllUpdateRequest {
    id: number;
}

export interface SourcesUserConnectionsAllUsedByListRequest {
    id: number;
}

export interface SourcesUserConnectionsOauthCreateRequest {
    userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest;
}

export interface SourcesUserConnectionsOauthDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsOauthListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    sourceSlug?: string;
}

export interface SourcesUserConnectionsOauthPartialUpdateRequest {
    id: number;
    patchedUserOAuthSourceConnectionRequest?: PatchedUserOAuthSourceConnectionRequest;
}

export interface SourcesUserConnectionsOauthRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsOauthUpdateRequest {
    id: number;
    userOAuthSourceConnectionRequest: UserOAuthSourceConnectionRequest;
}

export interface SourcesUserConnectionsOauthUsedByListRequest {
    id: number;
}

export interface SourcesUserConnectionsPlexCreateRequest {
    plexSourceConnectionRequest: PlexSourceConnectionRequest;
}

export interface SourcesUserConnectionsPlexDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsPlexListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    sourceSlug?: string;
}

export interface SourcesUserConnectionsPlexPartialUpdateRequest {
    id: number;
    patchedPlexSourceConnectionRequest?: PatchedPlexSourceConnectionRequest;
}

export interface SourcesUserConnectionsPlexRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsPlexUpdateRequest {
    id: number;
    plexSourceConnectionRequest: PlexSourceConnectionRequest;
}

export interface SourcesUserConnectionsPlexUsedByListRequest {
    id: number;
}

export interface SourcesUserConnectionsSamlCreateRequest {
    userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest;
}

export interface SourcesUserConnectionsSamlDestroyRequest {
    id: number;
}

export interface SourcesUserConnectionsSamlListRequest {
    ordering?: string;
    page?: number;
    pageSize?: number;
    search?: string;
    sourceSlug?: string;
}

export interface SourcesUserConnectionsSamlPartialUpdateRequest {
    id: number;
    patchedUserSAMLSourceConnectionRequest?: PatchedUserSAMLSourceConnectionRequest;
}

export interface SourcesUserConnectionsSamlRetrieveRequest {
    id: number;
}

export interface SourcesUserConnectionsSamlUpdateRequest {
    id: number;
    userSAMLSourceConnectionRequest: UserSAMLSourceConnectionRequest;
}

export interface SourcesUserConnectionsSamlUsedByListRequest {
    id: number;
}

/**
 * 
 */
export class SourcesApi extends runtime.BaseAPI {

    /**
     * Source Viewset
     */
    async sourcesAllDestroyRaw(requestParameters: SourcesAllDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesAllDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Source Viewset
     */
    async sourcesAllDestroy(requestParameters: SourcesAllDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesAllDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Source Viewset
     */
    async sourcesAllListRaw(requestParameters: SourcesAllListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSourceList>> {
        const queryParameters: any = {};

        if (requestParameters.managed !== undefined) {
            queryParameters['managed'] = requestParameters.managed;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSourceListFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesAllList(requestParameters: SourcesAllListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSourceList> {
        const response = await this.sourcesAllListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesAllRetrieveRaw(requestParameters: SourcesAllRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Source>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesAllRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SourceFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesAllRetrieve(requestParameters: SourcesAllRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Source> {
        const response = await this.sourcesAllRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Set source icon
     */
    async sourcesAllSetIconCreateRaw(requestParameters: SourcesAllSetIconCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesAllSetIconCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters.file !== undefined) {
            formParams.append('file', requestParameters.file as any);
        }

        if (requestParameters.clear !== undefined) {
            formParams.append('clear', requestParameters.clear as any);
        }

        const response = await this.request({
            path: `/sources/all/{slug}/set_icon/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set source icon
     */
    async sourcesAllSetIconCreate(requestParameters: SourcesAllSetIconCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesAllSetIconCreateRaw(requestParameters, initOverrides);
    }

    /**
     * Set source icon (as URL)
     */
    async sourcesAllSetIconUrlCreateRaw(requestParameters: SourcesAllSetIconUrlCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesAllSetIconUrlCreate.');
        }

        if (requestParameters.filePathRequest === null || requestParameters.filePathRequest === undefined) {
            throw new runtime.RequiredError('filePathRequest','Required parameter requestParameters.filePathRequest was null or undefined when calling sourcesAllSetIconUrlCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/{slug}/set_icon_url/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: FilePathRequestToJSON(requestParameters.filePathRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Set source icon (as URL)
     */
    async sourcesAllSetIconUrlCreate(requestParameters: SourcesAllSetIconUrlCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesAllSetIconUrlCreateRaw(requestParameters, initOverrides);
    }

    /**
     * Get all creatable source types
     */
    async sourcesAllTypesListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<TypeCreate>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/types/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TypeCreateFromJSON));
    }

    /**
     * Get all creatable source types
     */
    async sourcesAllTypesList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<TypeCreate>> {
        const response = await this.sourcesAllTypesListRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesAllUsedByListRaw(requestParameters: SourcesAllUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesAllUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/{slug}/used_by/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesAllUsedByList(requestParameters: SourcesAllUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesAllUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all sources the user can configure
     */
    async sourcesAllUserSettingsListRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UserSetting>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/all/user_settings/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UserSettingFromJSON));
    }

    /**
     * Get all sources the user can configure
     */
    async sourcesAllUserSettingsList(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UserSetting>> {
        const response = await this.sourcesAllUserSettingsListRaw(initOverrides);
        return await response.value();
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapCreateRaw(requestParameters: SourcesLdapCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LDAPSource>> {
        if (requestParameters.lDAPSourceRequest === null || requestParameters.lDAPSourceRequest === undefined) {
            throw new runtime.RequiredError('lDAPSourceRequest','Required parameter requestParameters.lDAPSourceRequest was null or undefined when calling sourcesLdapCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: LDAPSourceRequestToJSON(requestParameters.lDAPSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LDAPSourceFromJSON(jsonValue));
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapCreate(requestParameters: SourcesLdapCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LDAPSource> {
        const response = await this.sourcesLdapCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get raw LDAP data to debug
     */
    async sourcesLdapDebugRetrieveRaw(requestParameters: SourcesLdapDebugRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LDAPDebug>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapDebugRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/debug/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LDAPDebugFromJSON(jsonValue));
    }

    /**
     * Get raw LDAP data to debug
     */
    async sourcesLdapDebugRetrieve(requestParameters: SourcesLdapDebugRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LDAPDebug> {
        const response = await this.sourcesLdapDebugRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapDestroyRaw(requestParameters: SourcesLdapDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapDestroy(requestParameters: SourcesLdapDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesLdapDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapListRaw(requestParameters: SourcesLdapListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedLDAPSourceList>> {
        const queryParameters: any = {};

        if (requestParameters.additionalGroupDn !== undefined) {
            queryParameters['additional_group_dn'] = requestParameters.additionalGroupDn;
        }

        if (requestParameters.additionalUserDn !== undefined) {
            queryParameters['additional_user_dn'] = requestParameters.additionalUserDn;
        }

        if (requestParameters.baseDn !== undefined) {
            queryParameters['base_dn'] = requestParameters.baseDn;
        }

        if (requestParameters.bindCn !== undefined) {
            queryParameters['bind_cn'] = requestParameters.bindCn;
        }

        if (requestParameters.clientCertificate !== undefined) {
            queryParameters['client_certificate'] = requestParameters.clientCertificate;
        }

        if (requestParameters.enabled !== undefined) {
            queryParameters['enabled'] = requestParameters.enabled;
        }

        if (requestParameters.groupMembershipField !== undefined) {
            queryParameters['group_membership_field'] = requestParameters.groupMembershipField;
        }

        if (requestParameters.groupObjectFilter !== undefined) {
            queryParameters['group_object_filter'] = requestParameters.groupObjectFilter;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.objectUniquenessField !== undefined) {
            queryParameters['object_uniqueness_field'] = requestParameters.objectUniquenessField;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.peerCertificate !== undefined) {
            queryParameters['peer_certificate'] = requestParameters.peerCertificate;
        }

        if (requestParameters.propertyMappings) {
            queryParameters['property_mappings'] = requestParameters.propertyMappings;
        }

        if (requestParameters.propertyMappingsGroup) {
            queryParameters['property_mappings_group'] = requestParameters.propertyMappingsGroup;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.serverUri !== undefined) {
            queryParameters['server_uri'] = requestParameters.serverUri;
        }

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        if (requestParameters.sni !== undefined) {
            queryParameters['sni'] = requestParameters.sni;
        }

        if (requestParameters.startTls !== undefined) {
            queryParameters['start_tls'] = requestParameters.startTls;
        }

        if (requestParameters.syncGroups !== undefined) {
            queryParameters['sync_groups'] = requestParameters.syncGroups;
        }

        if (requestParameters.syncParentGroup !== undefined) {
            queryParameters['sync_parent_group'] = requestParameters.syncParentGroup;
        }

        if (requestParameters.syncUsers !== undefined) {
            queryParameters['sync_users'] = requestParameters.syncUsers;
        }

        if (requestParameters.syncUsersPassword !== undefined) {
            queryParameters['sync_users_password'] = requestParameters.syncUsersPassword;
        }

        if (requestParameters.userObjectFilter !== undefined) {
            queryParameters['user_object_filter'] = requestParameters.userObjectFilter;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedLDAPSourceListFromJSON(jsonValue));
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapList(requestParameters: SourcesLdapListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedLDAPSourceList> {
        const response = await this.sourcesLdapListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapPartialUpdateRaw(requestParameters: SourcesLdapPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LDAPSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedLDAPSourceRequestToJSON(requestParameters.patchedLDAPSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LDAPSourceFromJSON(jsonValue));
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapPartialUpdate(requestParameters: SourcesLdapPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LDAPSource> {
        const response = await this.sourcesLdapPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapRetrieveRaw(requestParameters: SourcesLdapRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LDAPSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LDAPSourceFromJSON(jsonValue));
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapRetrieve(requestParameters: SourcesLdapRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LDAPSource> {
        const response = await this.sourcesLdapRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get source\'s sync status
     */
    async sourcesLdapSyncStatusRetrieveRaw(requestParameters: SourcesLdapSyncStatusRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LDAPSyncStatus>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapSyncStatusRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/sync_status/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LDAPSyncStatusFromJSON(jsonValue));
    }

    /**
     * Get source\'s sync status
     */
    async sourcesLdapSyncStatusRetrieve(requestParameters: SourcesLdapSyncStatusRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LDAPSyncStatus> {
        const response = await this.sourcesLdapSyncStatusRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapUpdateRaw(requestParameters: SourcesLdapUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<LDAPSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapUpdate.');
        }

        if (requestParameters.lDAPSourceRequest === null || requestParameters.lDAPSourceRequest === undefined) {
            throw new runtime.RequiredError('lDAPSourceRequest','Required parameter requestParameters.lDAPSourceRequest was null or undefined when calling sourcesLdapUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: LDAPSourceRequestToJSON(requestParameters.lDAPSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => LDAPSourceFromJSON(jsonValue));
    }

    /**
     * LDAP Source Viewset
     */
    async sourcesLdapUpdate(requestParameters: SourcesLdapUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<LDAPSource> {
        const response = await this.sourcesLdapUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesLdapUsedByListRaw(requestParameters: SourcesLdapUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesLdapUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/ldap/{slug}/used_by/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesLdapUsedByList(requestParameters: SourcesLdapUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesLdapUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesOauthCreateRaw(requestParameters: SourcesOauthCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OAuthSource>> {
        if (requestParameters.oAuthSourceRequest === null || requestParameters.oAuthSourceRequest === undefined) {
            throw new runtime.RequiredError('oAuthSourceRequest','Required parameter requestParameters.oAuthSourceRequest was null or undefined when calling sourcesOauthCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: OAuthSourceRequestToJSON(requestParameters.oAuthSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OAuthSourceFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesOauthCreate(requestParameters: SourcesOauthCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OAuthSource> {
        const response = await this.sourcesOauthCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesOauthDestroyRaw(requestParameters: SourcesOauthDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesOauthDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Source Viewset
     */
    async sourcesOauthDestroy(requestParameters: SourcesOauthDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesOauthDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Source Viewset
     */
    async sourcesOauthListRaw(requestParameters: SourcesOauthListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedOAuthSourceList>> {
        const queryParameters: any = {};

        if (requestParameters.accessTokenUrl !== undefined) {
            queryParameters['access_token_url'] = requestParameters.accessTokenUrl;
        }

        if (requestParameters.additionalScopes !== undefined) {
            queryParameters['additional_scopes'] = requestParameters.additionalScopes;
        }

        if (requestParameters.authenticationFlow !== undefined) {
            queryParameters['authentication_flow'] = requestParameters.authenticationFlow;
        }

        if (requestParameters.authorizationUrl !== undefined) {
            queryParameters['authorization_url'] = requestParameters.authorizationUrl;
        }

        if (requestParameters.consumerKey !== undefined) {
            queryParameters['consumer_key'] = requestParameters.consumerKey;
        }

        if (requestParameters.enabled !== undefined) {
            queryParameters['enabled'] = requestParameters.enabled;
        }

        if (requestParameters.enrollmentFlow !== undefined) {
            queryParameters['enrollment_flow'] = requestParameters.enrollmentFlow;
        }

        if (requestParameters.hasJwks !== undefined) {
            queryParameters['has_jwks'] = requestParameters.hasJwks;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.policyEngineMode !== undefined) {
            queryParameters['policy_engine_mode'] = requestParameters.policyEngineMode;
        }

        if (requestParameters.profileUrl !== undefined) {
            queryParameters['profile_url'] = requestParameters.profileUrl;
        }

        if (requestParameters.providerType !== undefined) {
            queryParameters['provider_type'] = requestParameters.providerType;
        }

        if (requestParameters.requestTokenUrl !== undefined) {
            queryParameters['request_token_url'] = requestParameters.requestTokenUrl;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        if (requestParameters.userMatchingMode !== undefined) {
            queryParameters['user_matching_mode'] = requestParameters.userMatchingMode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedOAuthSourceListFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesOauthList(requestParameters: SourcesOauthListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedOAuthSourceList> {
        const response = await this.sourcesOauthListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesOauthPartialUpdateRaw(requestParameters: SourcesOauthPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OAuthSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesOauthPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedOAuthSourceRequestToJSON(requestParameters.patchedOAuthSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OAuthSourceFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesOauthPartialUpdate(requestParameters: SourcesOauthPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OAuthSource> {
        const response = await this.sourcesOauthPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesOauthRetrieveRaw(requestParameters: SourcesOauthRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OAuthSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesOauthRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OAuthSourceFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesOauthRetrieve(requestParameters: SourcesOauthRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OAuthSource> {
        const response = await this.sourcesOauthRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn\'t found, returns the default type.
     */
    async sourcesOauthSourceTypesListRaw(requestParameters: SourcesOauthSourceTypesListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SourceType>>> {
        const queryParameters: any = {};

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/source_types/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SourceTypeFromJSON));
    }

    /**
     * Get all creatable source types. If ?name is set, only returns the type for <name>. If <name> isn\'t found, returns the default type.
     */
    async sourcesOauthSourceTypesList(requestParameters: SourcesOauthSourceTypesListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SourceType>> {
        const response = await this.sourcesOauthSourceTypesListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesOauthUpdateRaw(requestParameters: SourcesOauthUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<OAuthSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesOauthUpdate.');
        }

        if (requestParameters.oAuthSourceRequest === null || requestParameters.oAuthSourceRequest === undefined) {
            throw new runtime.RequiredError('oAuthSourceRequest','Required parameter requestParameters.oAuthSourceRequest was null or undefined when calling sourcesOauthUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: OAuthSourceRequestToJSON(requestParameters.oAuthSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => OAuthSourceFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesOauthUpdate(requestParameters: SourcesOauthUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<OAuthSource> {
        const response = await this.sourcesOauthUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesOauthUsedByListRaw(requestParameters: SourcesOauthUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesOauthUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/oauth/{slug}/used_by/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesOauthUsedByList(requestParameters: SourcesOauthUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesOauthUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexCreateRaw(requestParameters: SourcesPlexCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSource>> {
        if (requestParameters.plexSourceRequest === null || requestParameters.plexSourceRequest === undefined) {
            throw new runtime.RequiredError('plexSourceRequest','Required parameter requestParameters.plexSourceRequest was null or undefined when calling sourcesPlexCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlexSourceRequestToJSON(requestParameters.plexSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceFromJSON(jsonValue));
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexCreate(requestParameters: SourcesPlexCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSource> {
        const response = await this.sourcesPlexCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexDestroyRaw(requestParameters: SourcesPlexDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesPlexDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexDestroy(requestParameters: SourcesPlexDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesPlexDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexListRaw(requestParameters: SourcesPlexListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPlexSourceList>> {
        const queryParameters: any = {};

        if (requestParameters.allowFriends !== undefined) {
            queryParameters['allow_friends'] = requestParameters.allowFriends;
        }

        if (requestParameters.authenticationFlow !== undefined) {
            queryParameters['authentication_flow'] = requestParameters.authenticationFlow;
        }

        if (requestParameters.clientId !== undefined) {
            queryParameters['client_id'] = requestParameters.clientId;
        }

        if (requestParameters.enabled !== undefined) {
            queryParameters['enabled'] = requestParameters.enabled;
        }

        if (requestParameters.enrollmentFlow !== undefined) {
            queryParameters['enrollment_flow'] = requestParameters.enrollmentFlow;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.policyEngineMode !== undefined) {
            queryParameters['policy_engine_mode'] = requestParameters.policyEngineMode;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        if (requestParameters.userMatchingMode !== undefined) {
            queryParameters['user_matching_mode'] = requestParameters.userMatchingMode;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPlexSourceListFromJSON(jsonValue));
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexList(requestParameters: SourcesPlexListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPlexSourceList> {
        const response = await this.sourcesPlexListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexPartialUpdateRaw(requestParameters: SourcesPlexPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesPlexPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPlexSourceRequestToJSON(requestParameters.patchedPlexSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceFromJSON(jsonValue));
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexPartialUpdate(requestParameters: SourcesPlexPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSource> {
        const response = await this.sourcesPlexPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Redeem a plex token for an authenticated user, creating a connection
     */
    async sourcesPlexRedeemTokenAuthenticatedCreateRaw(requestParameters: SourcesPlexRedeemTokenAuthenticatedCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.plexTokenRedeemRequest === null || requestParameters.plexTokenRedeemRequest === undefined) {
            throw new runtime.RequiredError('plexTokenRedeemRequest','Required parameter requestParameters.plexTokenRedeemRequest was null or undefined when calling sourcesPlexRedeemTokenAuthenticatedCreate.');
        }

        const queryParameters: any = {};

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/redeem_token_authenticated/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlexTokenRedeemRequestToJSON(requestParameters.plexTokenRedeemRequest),
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Redeem a plex token for an authenticated user, creating a connection
     */
    async sourcesPlexRedeemTokenAuthenticatedCreate(requestParameters: SourcesPlexRedeemTokenAuthenticatedCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesPlexRedeemTokenAuthenticatedCreateRaw(requestParameters, initOverrides);
    }

    /**
     * Redeem a plex token, check it\'s access to resources against what\'s allowed for the source, and redirect to an authentication/enrollment flow.
     */
    async sourcesPlexRedeemTokenCreateRaw(requestParameters: SourcesPlexRedeemTokenCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<RedirectChallenge>> {
        if (requestParameters.plexTokenRedeemRequest === null || requestParameters.plexTokenRedeemRequest === undefined) {
            throw new runtime.RequiredError('plexTokenRedeemRequest','Required parameter requestParameters.plexTokenRedeemRequest was null or undefined when calling sourcesPlexRedeemTokenCreate.');
        }

        const queryParameters: any = {};

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/redeem_token/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlexTokenRedeemRequestToJSON(requestParameters.plexTokenRedeemRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => RedirectChallengeFromJSON(jsonValue));
    }

    /**
     * Redeem a plex token, check it\'s access to resources against what\'s allowed for the source, and redirect to an authentication/enrollment flow.
     */
    async sourcesPlexRedeemTokenCreate(requestParameters: SourcesPlexRedeemTokenCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<RedirectChallenge> {
        const response = await this.sourcesPlexRedeemTokenCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexRetrieveRaw(requestParameters: SourcesPlexRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesPlexRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceFromJSON(jsonValue));
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexRetrieve(requestParameters: SourcesPlexRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSource> {
        const response = await this.sourcesPlexRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexUpdateRaw(requestParameters: SourcesPlexUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesPlexUpdate.');
        }

        if (requestParameters.plexSourceRequest === null || requestParameters.plexSourceRequest === undefined) {
            throw new runtime.RequiredError('plexSourceRequest','Required parameter requestParameters.plexSourceRequest was null or undefined when calling sourcesPlexUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PlexSourceRequestToJSON(requestParameters.plexSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceFromJSON(jsonValue));
    }

    /**
     * Plex source Viewset
     */
    async sourcesPlexUpdate(requestParameters: SourcesPlexUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSource> {
        const response = await this.sourcesPlexUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesPlexUsedByListRaw(requestParameters: SourcesPlexUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesPlexUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/plex/{slug}/used_by/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesPlexUsedByList(requestParameters: SourcesPlexUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesPlexUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlCreateRaw(requestParameters: SourcesSamlCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLSource>> {
        if (requestParameters.sAMLSourceRequest === null || requestParameters.sAMLSourceRequest === undefined) {
            throw new runtime.RequiredError('sAMLSourceRequest','Required parameter requestParameters.sAMLSourceRequest was null or undefined when calling sourcesSamlCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: SAMLSourceRequestToJSON(requestParameters.sAMLSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLSourceFromJSON(jsonValue));
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlCreate(requestParameters: SourcesSamlCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLSource> {
        const response = await this.sourcesSamlCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlDestroyRaw(requestParameters: SourcesSamlDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesSamlDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlDestroy(requestParameters: SourcesSamlDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesSamlDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlListRaw(requestParameters: SourcesSamlListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedSAMLSourceList>> {
        const queryParameters: any = {};

        if (requestParameters.allowIdpInitiated !== undefined) {
            queryParameters['allow_idp_initiated'] = requestParameters.allowIdpInitiated;
        }

        if (requestParameters.authenticationFlow !== undefined) {
            queryParameters['authentication_flow'] = requestParameters.authenticationFlow;
        }

        if (requestParameters.bindingType !== undefined) {
            queryParameters['binding_type'] = requestParameters.bindingType;
        }

        if (requestParameters.digestAlgorithm !== undefined) {
            queryParameters['digest_algorithm'] = requestParameters.digestAlgorithm;
        }

        if (requestParameters.enabled !== undefined) {
            queryParameters['enabled'] = requestParameters.enabled;
        }

        if (requestParameters.enrollmentFlow !== undefined) {
            queryParameters['enrollment_flow'] = requestParameters.enrollmentFlow;
        }

        if (requestParameters.issuer !== undefined) {
            queryParameters['issuer'] = requestParameters.issuer;
        }

        if (requestParameters.managed !== undefined) {
            queryParameters['managed'] = requestParameters.managed;
        }

        if (requestParameters.name !== undefined) {
            queryParameters['name'] = requestParameters.name;
        }

        if (requestParameters.nameIdPolicy !== undefined) {
            queryParameters['name_id_policy'] = requestParameters.nameIdPolicy;
        }

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.policyEngineMode !== undefined) {
            queryParameters['policy_engine_mode'] = requestParameters.policyEngineMode;
        }

        if (requestParameters.preAuthenticationFlow !== undefined) {
            queryParameters['pre_authentication_flow'] = requestParameters.preAuthenticationFlow;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.signatureAlgorithm !== undefined) {
            queryParameters['signature_algorithm'] = requestParameters.signatureAlgorithm;
        }

        if (requestParameters.signingKp !== undefined) {
            queryParameters['signing_kp'] = requestParameters.signingKp;
        }

        if (requestParameters.sloUrl !== undefined) {
            queryParameters['slo_url'] = requestParameters.sloUrl;
        }

        if (requestParameters.slug !== undefined) {
            queryParameters['slug'] = requestParameters.slug;
        }

        if (requestParameters.ssoUrl !== undefined) {
            queryParameters['sso_url'] = requestParameters.ssoUrl;
        }

        if (requestParameters.temporaryUserDeleteAfter !== undefined) {
            queryParameters['temporary_user_delete_after'] = requestParameters.temporaryUserDeleteAfter;
        }

        if (requestParameters.userMatchingMode !== undefined) {
            queryParameters['user_matching_mode'] = requestParameters.userMatchingMode;
        }

        if (requestParameters.verificationKp !== undefined) {
            queryParameters['verification_kp'] = requestParameters.verificationKp;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedSAMLSourceListFromJSON(jsonValue));
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlList(requestParameters: SourcesSamlListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedSAMLSourceList> {
        const response = await this.sourcesSamlListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Return metadata as XML string
     */
    async sourcesSamlMetadataRetrieveRaw(requestParameters: SourcesSamlMetadataRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLMetadata>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesSamlMetadataRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/{slug}/metadata/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLMetadataFromJSON(jsonValue));
    }

    /**
     * Return metadata as XML string
     */
    async sourcesSamlMetadataRetrieve(requestParameters: SourcesSamlMetadataRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLMetadata> {
        const response = await this.sourcesSamlMetadataRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlPartialUpdateRaw(requestParameters: SourcesSamlPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesSamlPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedSAMLSourceRequestToJSON(requestParameters.patchedSAMLSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLSourceFromJSON(jsonValue));
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlPartialUpdate(requestParameters: SourcesSamlPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLSource> {
        const response = await this.sourcesSamlPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlRetrieveRaw(requestParameters: SourcesSamlRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesSamlRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLSourceFromJSON(jsonValue));
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlRetrieve(requestParameters: SourcesSamlRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLSource> {
        const response = await this.sourcesSamlRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlUpdateRaw(requestParameters: SourcesSamlUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<SAMLSource>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesSamlUpdate.');
        }

        if (requestParameters.sAMLSourceRequest === null || requestParameters.sAMLSourceRequest === undefined) {
            throw new runtime.RequiredError('sAMLSourceRequest','Required parameter requestParameters.sAMLSourceRequest was null or undefined when calling sourcesSamlUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/{slug}/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: SAMLSourceRequestToJSON(requestParameters.sAMLSourceRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => SAMLSourceFromJSON(jsonValue));
    }

    /**
     * SAMLSource Viewset
     */
    async sourcesSamlUpdate(requestParameters: SourcesSamlUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<SAMLSource> {
        const response = await this.sourcesSamlUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesSamlUsedByListRaw(requestParameters: SourcesSamlUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.slug === null || requestParameters.slug === undefined) {
            throw new runtime.RequiredError('slug','Required parameter requestParameters.slug was null or undefined when calling sourcesSamlUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/saml/{slug}/used_by/`.replace(`{${"slug"}}`, encodeURIComponent(String(requestParameters.slug))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesSamlUsedByList(requestParameters: SourcesSamlUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesSamlUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllDestroyRaw(requestParameters: SourcesUserConnectionsAllDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsAllDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/all/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllDestroy(requestParameters: SourcesUserConnectionsAllDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesUserConnectionsAllDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllListRaw(requestParameters: SourcesUserConnectionsAllListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUserSourceConnectionList>> {
        const queryParameters: any = {};

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.user !== undefined) {
            queryParameters['user'] = requestParameters.user;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/all/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUserSourceConnectionListFromJSON(jsonValue));
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllList(requestParameters: SourcesUserConnectionsAllListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUserSourceConnectionList> {
        const response = await this.sourcesUserConnectionsAllListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllPartialUpdateRaw(requestParameters: SourcesUserConnectionsAllPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsAllPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/all/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSourceConnectionFromJSON(jsonValue));
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllPartialUpdate(requestParameters: SourcesUserConnectionsAllPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSourceConnection> {
        const response = await this.sourcesUserConnectionsAllPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllRetrieveRaw(requestParameters: SourcesUserConnectionsAllRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsAllRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/all/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSourceConnectionFromJSON(jsonValue));
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllRetrieve(requestParameters: SourcesUserConnectionsAllRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSourceConnection> {
        const response = await this.sourcesUserConnectionsAllRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllUpdateRaw(requestParameters: SourcesUserConnectionsAllUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsAllUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/all/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSourceConnectionFromJSON(jsonValue));
    }

    /**
     * User-source connection Viewset
     */
    async sourcesUserConnectionsAllUpdate(requestParameters: SourcesUserConnectionsAllUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSourceConnection> {
        const response = await this.sourcesUserConnectionsAllUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsAllUsedByListRaw(requestParameters: SourcesUserConnectionsAllUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsAllUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/all/{id}/used_by/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsAllUsedByList(requestParameters: SourcesUserConnectionsAllUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesUserConnectionsAllUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthCreateRaw(requestParameters: SourcesUserConnectionsOauthCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserOAuthSourceConnection>> {
        if (requestParameters.userOAuthSourceConnectionRequest === null || requestParameters.userOAuthSourceConnectionRequest === undefined) {
            throw new runtime.RequiredError('userOAuthSourceConnectionRequest','Required parameter requestParameters.userOAuthSourceConnectionRequest was null or undefined when calling sourcesUserConnectionsOauthCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserOAuthSourceConnectionRequestToJSON(requestParameters.userOAuthSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserOAuthSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthCreate(requestParameters: SourcesUserConnectionsOauthCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserOAuthSourceConnection> {
        const response = await this.sourcesUserConnectionsOauthCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthDestroyRaw(requestParameters: SourcesUserConnectionsOauthDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsOauthDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthDestroy(requestParameters: SourcesUserConnectionsOauthDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesUserConnectionsOauthDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthListRaw(requestParameters: SourcesUserConnectionsOauthListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUserOAuthSourceConnectionList>> {
        const queryParameters: any = {};

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.sourceSlug !== undefined) {
            queryParameters['source__slug'] = requestParameters.sourceSlug;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUserOAuthSourceConnectionListFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthList(requestParameters: SourcesUserConnectionsOauthListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUserOAuthSourceConnectionList> {
        const response = await this.sourcesUserConnectionsOauthListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthPartialUpdateRaw(requestParameters: SourcesUserConnectionsOauthPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserOAuthSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsOauthPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserOAuthSourceConnectionRequestToJSON(requestParameters.patchedUserOAuthSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserOAuthSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthPartialUpdate(requestParameters: SourcesUserConnectionsOauthPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserOAuthSourceConnection> {
        const response = await this.sourcesUserConnectionsOauthPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthRetrieveRaw(requestParameters: SourcesUserConnectionsOauthRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserOAuthSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsOauthRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserOAuthSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthRetrieve(requestParameters: SourcesUserConnectionsOauthRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserOAuthSourceConnection> {
        const response = await this.sourcesUserConnectionsOauthRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthUpdateRaw(requestParameters: SourcesUserConnectionsOauthUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserOAuthSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsOauthUpdate.');
        }

        if (requestParameters.userOAuthSourceConnectionRequest === null || requestParameters.userOAuthSourceConnectionRequest === undefined) {
            throw new runtime.RequiredError('userOAuthSourceConnectionRequest','Required parameter requestParameters.userOAuthSourceConnectionRequest was null or undefined when calling sourcesUserConnectionsOauthUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserOAuthSourceConnectionRequestToJSON(requestParameters.userOAuthSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserOAuthSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsOauthUpdate(requestParameters: SourcesUserConnectionsOauthUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserOAuthSourceConnection> {
        const response = await this.sourcesUserConnectionsOauthUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsOauthUsedByListRaw(requestParameters: SourcesUserConnectionsOauthUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsOauthUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/oauth/{id}/used_by/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsOauthUsedByList(requestParameters: SourcesUserConnectionsOauthUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesUserConnectionsOauthUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexCreateRaw(requestParameters: SourcesUserConnectionsPlexCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSourceConnection>> {
        if (requestParameters.plexSourceConnectionRequest === null || requestParameters.plexSourceConnectionRequest === undefined) {
            throw new runtime.RequiredError('plexSourceConnectionRequest','Required parameter requestParameters.plexSourceConnectionRequest was null or undefined when calling sourcesUserConnectionsPlexCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: PlexSourceConnectionRequestToJSON(requestParameters.plexSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexCreate(requestParameters: SourcesUserConnectionsPlexCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSourceConnection> {
        const response = await this.sourcesUserConnectionsPlexCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexDestroyRaw(requestParameters: SourcesUserConnectionsPlexDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsPlexDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexDestroy(requestParameters: SourcesUserConnectionsPlexDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesUserConnectionsPlexDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexListRaw(requestParameters: SourcesUserConnectionsPlexListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedPlexSourceConnectionList>> {
        const queryParameters: any = {};

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.sourceSlug !== undefined) {
            queryParameters['source__slug'] = requestParameters.sourceSlug;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedPlexSourceConnectionListFromJSON(jsonValue));
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexList(requestParameters: SourcesUserConnectionsPlexListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedPlexSourceConnectionList> {
        const response = await this.sourcesUserConnectionsPlexListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexPartialUpdateRaw(requestParameters: SourcesUserConnectionsPlexPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsPlexPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedPlexSourceConnectionRequestToJSON(requestParameters.patchedPlexSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexPartialUpdate(requestParameters: SourcesUserConnectionsPlexPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSourceConnection> {
        const response = await this.sourcesUserConnectionsPlexPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexRetrieveRaw(requestParameters: SourcesUserConnectionsPlexRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsPlexRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexRetrieve(requestParameters: SourcesUserConnectionsPlexRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSourceConnection> {
        const response = await this.sourcesUserConnectionsPlexRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexUpdateRaw(requestParameters: SourcesUserConnectionsPlexUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PlexSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsPlexUpdate.');
        }

        if (requestParameters.plexSourceConnectionRequest === null || requestParameters.plexSourceConnectionRequest === undefined) {
            throw new runtime.RequiredError('plexSourceConnectionRequest','Required parameter requestParameters.plexSourceConnectionRequest was null or undefined when calling sourcesUserConnectionsPlexUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: PlexSourceConnectionRequestToJSON(requestParameters.plexSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PlexSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Plex Source connection Serializer
     */
    async sourcesUserConnectionsPlexUpdate(requestParameters: SourcesUserConnectionsPlexUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PlexSourceConnection> {
        const response = await this.sourcesUserConnectionsPlexUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsPlexUsedByListRaw(requestParameters: SourcesUserConnectionsPlexUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsPlexUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/plex/{id}/used_by/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsPlexUsedByList(requestParameters: SourcesUserConnectionsPlexUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesUserConnectionsPlexUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlCreateRaw(requestParameters: SourcesUserConnectionsSamlCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSAMLSourceConnection>> {
        if (requestParameters.userSAMLSourceConnectionRequest === null || requestParameters.userSAMLSourceConnectionRequest === undefined) {
            throw new runtime.RequiredError('userSAMLSourceConnectionRequest','Required parameter requestParameters.userSAMLSourceConnectionRequest was null or undefined when calling sourcesUserConnectionsSamlCreate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/`,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: UserSAMLSourceConnectionRequestToJSON(requestParameters.userSAMLSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSAMLSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlCreate(requestParameters: SourcesUserConnectionsSamlCreateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSAMLSourceConnection> {
        const response = await this.sourcesUserConnectionsSamlCreateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlDestroyRaw(requestParameters: SourcesUserConnectionsSamlDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<void>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsSamlDestroy.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'DELETE',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.VoidApiResponse(response);
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlDestroy(requestParameters: SourcesUserConnectionsSamlDestroyRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<void> {
        await this.sourcesUserConnectionsSamlDestroyRaw(requestParameters, initOverrides);
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlListRaw(requestParameters: SourcesUserConnectionsSamlListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<PaginatedUserSAMLSourceConnectionList>> {
        const queryParameters: any = {};

        if (requestParameters.ordering !== undefined) {
            queryParameters['ordering'] = requestParameters.ordering;
        }

        if (requestParameters.page !== undefined) {
            queryParameters['page'] = requestParameters.page;
        }

        if (requestParameters.pageSize !== undefined) {
            queryParameters['page_size'] = requestParameters.pageSize;
        }

        if (requestParameters.search !== undefined) {
            queryParameters['search'] = requestParameters.search;
        }

        if (requestParameters.sourceSlug !== undefined) {
            queryParameters['source__slug'] = requestParameters.sourceSlug;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => PaginatedUserSAMLSourceConnectionListFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlList(requestParameters: SourcesUserConnectionsSamlListRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<PaginatedUserSAMLSourceConnectionList> {
        const response = await this.sourcesUserConnectionsSamlListRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlPartialUpdateRaw(requestParameters: SourcesUserConnectionsSamlPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSAMLSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsSamlPartialUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PATCH',
            headers: headerParameters,
            query: queryParameters,
            body: PatchedUserSAMLSourceConnectionRequestToJSON(requestParameters.patchedUserSAMLSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSAMLSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlPartialUpdate(requestParameters: SourcesUserConnectionsSamlPartialUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSAMLSourceConnection> {
        const response = await this.sourcesUserConnectionsSamlPartialUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlRetrieveRaw(requestParameters: SourcesUserConnectionsSamlRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSAMLSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsSamlRetrieve.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSAMLSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlRetrieve(requestParameters: SourcesUserConnectionsSamlRetrieveRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSAMLSourceConnection> {
        const response = await this.sourcesUserConnectionsSamlRetrieveRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlUpdateRaw(requestParameters: SourcesUserConnectionsSamlUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<UserSAMLSourceConnection>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsSamlUpdate.');
        }

        if (requestParameters.userSAMLSourceConnectionRequest === null || requestParameters.userSAMLSourceConnectionRequest === undefined) {
            throw new runtime.RequiredError('userSAMLSourceConnectionRequest','Required parameter requestParameters.userSAMLSourceConnectionRequest was null or undefined when calling sourcesUserConnectionsSamlUpdate.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/{id}/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'PUT',
            headers: headerParameters,
            query: queryParameters,
            body: UserSAMLSourceConnectionRequestToJSON(requestParameters.userSAMLSourceConnectionRequest),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => UserSAMLSourceConnectionFromJSON(jsonValue));
    }

    /**
     * Source Viewset
     */
    async sourcesUserConnectionsSamlUpdate(requestParameters: SourcesUserConnectionsSamlUpdateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<UserSAMLSourceConnection> {
        const response = await this.sourcesUserConnectionsSamlUpdateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsSamlUsedByListRaw(requestParameters: SourcesUserConnectionsSamlUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<UsedBy>>> {
        if (requestParameters.id === null || requestParameters.id === undefined) {
            throw new runtime.RequiredError('id','Required parameter requestParameters.id was null or undefined when calling sourcesUserConnectionsSamlUsedByList.');
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            headerParameters["Authorization"] = this.configuration.apiKey("Authorization"); // authentik authentication
        }

        const response = await this.request({
            path: `/sources/user_connections/saml/{id}/used_by/`.replace(`{${"id"}}`, encodeURIComponent(String(requestParameters.id))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(UsedByFromJSON));
    }

    /**
     * Get a list of all objects that use this object
     */
    async sourcesUserConnectionsSamlUsedByList(requestParameters: SourcesUserConnectionsSamlUsedByListRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<UsedBy>> {
        const response = await this.sourcesUserConnectionsSamlUsedByListRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const SourcesOauthListPolicyEngineModeEnum = {
    All: 'all',
    Any: 'any',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesOauthListPolicyEngineModeEnum = typeof SourcesOauthListPolicyEngineModeEnum[keyof typeof SourcesOauthListPolicyEngineModeEnum];
/**
 * @export
 */
export const SourcesOauthListUserMatchingModeEnum = {
    EmailDeny: 'email_deny',
    EmailLink: 'email_link',
    Identifier: 'identifier',
    UsernameDeny: 'username_deny',
    UsernameLink: 'username_link',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesOauthListUserMatchingModeEnum = typeof SourcesOauthListUserMatchingModeEnum[keyof typeof SourcesOauthListUserMatchingModeEnum];
/**
 * @export
 */
export const SourcesPlexListPolicyEngineModeEnum = {
    All: 'all',
    Any: 'any',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesPlexListPolicyEngineModeEnum = typeof SourcesPlexListPolicyEngineModeEnum[keyof typeof SourcesPlexListPolicyEngineModeEnum];
/**
 * @export
 */
export const SourcesPlexListUserMatchingModeEnum = {
    EmailDeny: 'email_deny',
    EmailLink: 'email_link',
    Identifier: 'identifier',
    UsernameDeny: 'username_deny',
    UsernameLink: 'username_link',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesPlexListUserMatchingModeEnum = typeof SourcesPlexListUserMatchingModeEnum[keyof typeof SourcesPlexListUserMatchingModeEnum];
/**
 * @export
 */
export const SourcesSamlListBindingTypeEnum = {
    Post: 'POST',
    PostAuto: 'POST_AUTO',
    Redirect: 'REDIRECT',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesSamlListBindingTypeEnum = typeof SourcesSamlListBindingTypeEnum[keyof typeof SourcesSamlListBindingTypeEnum];
/**
 * @export
 */
export const SourcesSamlListDigestAlgorithmEnum = {
    _200009Xmldsigsha1: 'http://www.w3.org/2000/09/xmldsig#sha1',
    _200104XmldsigMoresha384: 'http://www.w3.org/2001/04/xmldsig-more#sha384',
    _200104Xmlencsha256: 'http://www.w3.org/2001/04/xmlenc#sha256',
    _200104Xmlencsha512: 'http://www.w3.org/2001/04/xmlenc#sha512',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesSamlListDigestAlgorithmEnum = typeof SourcesSamlListDigestAlgorithmEnum[keyof typeof SourcesSamlListDigestAlgorithmEnum];
/**
 * @export
 */
export const SourcesSamlListNameIdPolicyEnum = {
    _11nameidFormatemailAddress: 'urn:oasis:names:tc:SAML:1.1:nameid-format:emailAddress',
    _20nameidFormatWindowsDomainQualifiedName: 'urn:oasis:names:tc:SAML:2.0:nameid-format:WindowsDomainQualifiedName',
    _20nameidFormatX509SubjectName: 'urn:oasis:names:tc:SAML:2.0:nameid-format:X509SubjectName',
    _20nameidFormatpersistent: 'urn:oasis:names:tc:SAML:2.0:nameid-format:persistent',
    _20nameidFormattransient: 'urn:oasis:names:tc:SAML:2.0:nameid-format:transient',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesSamlListNameIdPolicyEnum = typeof SourcesSamlListNameIdPolicyEnum[keyof typeof SourcesSamlListNameIdPolicyEnum];
/**
 * @export
 */
export const SourcesSamlListPolicyEngineModeEnum = {
    All: 'all',
    Any: 'any',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesSamlListPolicyEngineModeEnum = typeof SourcesSamlListPolicyEngineModeEnum[keyof typeof SourcesSamlListPolicyEngineModeEnum];
/**
 * @export
 */
export const SourcesSamlListSignatureAlgorithmEnum = {
    _200009XmldsigdsaSha1: 'http://www.w3.org/2000/09/xmldsig#dsa-sha1',
    _200009XmldsigrsaSha1: 'http://www.w3.org/2000/09/xmldsig#rsa-sha1',
    _200104XmldsigMorersaSha256: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha256',
    _200104XmldsigMorersaSha384: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha384',
    _200104XmldsigMorersaSha512: 'http://www.w3.org/2001/04/xmldsig-more#rsa-sha512',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesSamlListSignatureAlgorithmEnum = typeof SourcesSamlListSignatureAlgorithmEnum[keyof typeof SourcesSamlListSignatureAlgorithmEnum];
/**
 * @export
 */
export const SourcesSamlListUserMatchingModeEnum = {
    EmailDeny: 'email_deny',
    EmailLink: 'email_link',
    Identifier: 'identifier',
    UsernameDeny: 'username_deny',
    UsernameLink: 'username_link',
    UnknownDefaultOpenApi: '11184809'
} as const;
export type SourcesSamlListUserMatchingModeEnum = typeof SourcesSamlListUserMatchingModeEnum[keyof typeof SourcesSamlListUserMatchingModeEnum];
